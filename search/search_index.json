{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Locasticsearch Serverless full text search in Python \u26a0\ufe0f alpha status : \ud83d\udea7 Come back in a couple weekends \ud83d\udea7 Locasticsearch provides serverless full text search powered by sqlite full text search capabilities but trying to be compatible with (a subset of) the elasticsearch API. That way you can comfortably develop your text search appplication without needing to set up services and smoothly transition to Elasticsearch for scale or more features without changing your code. That said, if you are only doing basic search operations within the subset supported by this library, and dont have a lot of documents (~million) that would justify going for a cluster deployment, Locasticsearch can be a faster alternative to Elasticsearch. Getting started from locasticsearch import Locasticsearch from datetime import datetime es = Locasticsearch() doc = { \"author\": \"kimchy\", \"text\": \"Elasticsearch: cool. bonsai cool.\", \"timestamp\": datetime(2010, 10, 10, 10, 10, 10), } res = es.index(index=\"test-index\", doc_type=\"tweet\", id=1, body=doc) res = es.get(index=\"test-index\", doc_type=\"tweet\", id=1) print(res[\"_source\"]) # this will get ignored in Locasticsearch es.indices.refresh(index=\"test-index\") res = es.search(index=\"test-index\", body={\"query\": {\"match_all\": {}}}) print(\"Got %d Hits:\" % res[\"hits\"][\"total\"][\"value\"]) for hit in res[\"hits\"][\"hits\"]: print(\"%(timestamp)s %(author)s: %(text)s\" % hit[\"_source\"]) We are also adding a simplified API that can be converted to Elasticsearch. Features \ud83d\udcaf% local, no server management \u2728 Lightweight pure python, no external dependencies \u26a1 Super fast searches thanks to sqlite full text search capabilities \ud83d\udd17 No lock in. Thanks to the API compatiblity with the official client, you can smoothly transition to Elasticsearch for scale or more features without changing your code. Install pip install locasticsearch To use or not to use You should NOT use Locasticsearch if: you are deploying a security sensitive application. Locasticsearch code is very prone to SQL injection attacks. This should improve in future releases. Your searches are more complicated than what you would find in a 5 min Elasticsearch tutorial. Elasticsearch has a huge API and it is very unlikely that we can support even a sizable portion of that. You hate buggy libraries. Locasticsearch is a very young project so bugs are guaranteed. You can check the tests to see if your needs are covered. You should use Locasticsearch if: you dont want a docker or an elasticsearch service using precious resources in your laptop you only need basic text search and Elasticsearch would be overkill you want very easy deployments that only involve pip installs using Java from a python program makes you feel dirty Next steps [] Add a real query DSL parsing [] Add simplified non ES compatible interface for easy JSON ingestion, querying [] Document supported vs unsupported query types Comparison to similar libraries whoosh The most full featured pure python text search library by far: \ud83d\udc4d Supports highlight, analyzers, query expansion, several ranking functions, ... \ud83d\udc4e Unmaintained for a long time might see a revival at https://github.com/whoosh-community/whoosh \ud83d\udc4d Pure python so doesnt scale as well (still fast enough for small medium datasets) elasticsearch The big champion of full text search. This is what you should be using in production: \ud83d\udc4d Lots of features to accomodate any use case \ud83d\udc4d Battle tested, scalable, performant \ud83d\udc4e Non python native: more complex to deploy/integrate with python project for easy use cases django haystack Django Haystack provides an unified API that allows you to plug in different search backends (such as Solr, Elasticsearch, Whoosh, Xapian, etc.) without having to modify your code: \ud83d\udc4d Many features, boosting, highlight, autocomplete (some backend dependent though) \ud83d\udc4d Possibility to switch backends \ud83d\udc4e Library lock in. \ud83d\udc4e Despite supporting several backends, Whoosh is the only one that is python native. xapian \ud83d\udc4d Very fast and full featured (C++) \ud83d\udc4e No pip installable (needs system level compilation) \ud83d\udc4e The python bindings and the documentation are not that user friendly gensim While gensim focuses on topic modeling you can use TfidfModel and SparseMatrixSimilarity for text search. That said this is doesnt use an inverted index (linear search) so it has limited scalability. \ud83d\udc4d Unique features such as approximate search \ud83d\udc4e Focus is on topic modeling, so no intuitive APIs for full text ingestion/search \ud83d\udc4e Doesnt support inverted indexes search (mostly full scan and approximate) peewee Peewee is actually a more general ORM but offers abstractions to use full text search on Sqlite. \ud83d\udc4d Support for full text search using several SQL backends (no elasticsearch though) \ud83d\udc4d Custom ranking and analyzer functions \ud83d\udc4e No elasticsearch compatible API","title":"locasticsearch"},{"location":"#locasticsearch","text":"Serverless full text search in Python \u26a0\ufe0f alpha status : \ud83d\udea7 Come back in a couple weekends \ud83d\udea7 Locasticsearch provides serverless full text search powered by sqlite full text search capabilities but trying to be compatible with (a subset of) the elasticsearch API. That way you can comfortably develop your text search appplication without needing to set up services and smoothly transition to Elasticsearch for scale or more features without changing your code. That said, if you are only doing basic search operations within the subset supported by this library, and dont have a lot of documents (~million) that would justify going for a cluster deployment, Locasticsearch can be a faster alternative to Elasticsearch.","title":"Locasticsearch"},{"location":"#getting-started","text":"from locasticsearch import Locasticsearch from datetime import datetime es = Locasticsearch() doc = { \"author\": \"kimchy\", \"text\": \"Elasticsearch: cool. bonsai cool.\", \"timestamp\": datetime(2010, 10, 10, 10, 10, 10), } res = es.index(index=\"test-index\", doc_type=\"tweet\", id=1, body=doc) res = es.get(index=\"test-index\", doc_type=\"tweet\", id=1) print(res[\"_source\"]) # this will get ignored in Locasticsearch es.indices.refresh(index=\"test-index\") res = es.search(index=\"test-index\", body={\"query\": {\"match_all\": {}}}) print(\"Got %d Hits:\" % res[\"hits\"][\"total\"][\"value\"]) for hit in res[\"hits\"][\"hits\"]: print(\"%(timestamp)s %(author)s: %(text)s\" % hit[\"_source\"]) We are also adding a simplified API that can be converted to Elasticsearch.","title":"Getting started"},{"location":"#features","text":"\ud83d\udcaf% local, no server management \u2728 Lightweight pure python, no external dependencies \u26a1 Super fast searches thanks to sqlite full text search capabilities \ud83d\udd17 No lock in. Thanks to the API compatiblity with the official client, you can smoothly transition to Elasticsearch for scale or more features without changing your code.","title":"Features"},{"location":"#install","text":"pip install locasticsearch","title":"Install"},{"location":"#to-use-or-not-to-use","text":"You should NOT use Locasticsearch if: you are deploying a security sensitive application. Locasticsearch code is very prone to SQL injection attacks. This should improve in future releases. Your searches are more complicated than what you would find in a 5 min Elasticsearch tutorial. Elasticsearch has a huge API and it is very unlikely that we can support even a sizable portion of that. You hate buggy libraries. Locasticsearch is a very young project so bugs are guaranteed. You can check the tests to see if your needs are covered. You should use Locasticsearch if: you dont want a docker or an elasticsearch service using precious resources in your laptop you only need basic text search and Elasticsearch would be overkill you want very easy deployments that only involve pip installs using Java from a python program makes you feel dirty","title":"To use or not to use"},{"location":"#next-steps","text":"[] Add a real query DSL parsing [] Add simplified non ES compatible interface for easy JSON ingestion, querying [] Document supported vs unsupported query types","title":"Next steps"},{"location":"#comparison-to-similar-libraries","text":"","title":"Comparison to similar libraries"},{"location":"#whoosh","text":"The most full featured pure python text search library by far: \ud83d\udc4d Supports highlight, analyzers, query expansion, several ranking functions, ... \ud83d\udc4e Unmaintained for a long time might see a revival at https://github.com/whoosh-community/whoosh \ud83d\udc4d Pure python so doesnt scale as well (still fast enough for small medium datasets)","title":"whoosh"},{"location":"#elasticsearch","text":"The big champion of full text search. This is what you should be using in production: \ud83d\udc4d Lots of features to accomodate any use case \ud83d\udc4d Battle tested, scalable, performant \ud83d\udc4e Non python native: more complex to deploy/integrate with python project for easy use cases","title":"elasticsearch"},{"location":"#django-haystack","text":"Django Haystack provides an unified API that allows you to plug in different search backends (such as Solr, Elasticsearch, Whoosh, Xapian, etc.) without having to modify your code: \ud83d\udc4d Many features, boosting, highlight, autocomplete (some backend dependent though) \ud83d\udc4d Possibility to switch backends \ud83d\udc4e Library lock in. \ud83d\udc4e Despite supporting several backends, Whoosh is the only one that is python native.","title":"django haystack"},{"location":"#xapian","text":"\ud83d\udc4d Very fast and full featured (C++) \ud83d\udc4e No pip installable (needs system level compilation) \ud83d\udc4e The python bindings and the documentation are not that user friendly","title":"xapian"},{"location":"#gensim","text":"While gensim focuses on topic modeling you can use TfidfModel and SparseMatrixSimilarity for text search. That said this is doesnt use an inverted index (linear search) so it has limited scalability. \ud83d\udc4d Unique features such as approximate search \ud83d\udc4e Focus is on topic modeling, so no intuitive APIs for full text ingestion/search \ud83d\udc4e Doesnt support inverted indexes search (mostly full scan and approximate)","title":"gensim"},{"location":"#peewee","text":"Peewee is actually a more general ORM but offers abstractions to use full text search on Sqlite. \ud83d\udc4d Support for full text search using several SQL backends (no elasticsearch though) \ud83d\udc4d Custom ranking and analyzer functions \ud83d\udc4e No elasticsearch compatible API","title":"peewee"}]}